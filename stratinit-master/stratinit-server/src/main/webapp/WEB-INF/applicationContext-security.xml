<?xml version="1.0" encoding="UTF-8"?>

	<!--
		- Sample namespace-based configuration - - $Id:
		applicationContext-security.xml 3019 2008-05-01 17:51:48Z luke_t $
	-->

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:security="http://www.springframework.org/schema/security"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
                         http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
                        http://www.springframework.org/schema/security
                         http://www.springframework.org/schema/security/spring-security-2.0.4.xsd">

	<http auto-config="false" xmlns="http://www.springframework.org/schema/security">
		<http-basic />
		<intercept-url pattern="/remoting/**" access="ROLE_USER" />
		<intercept-url pattern="/admin/**" access="ROLE_ADMIN" />
		<intercept-url pattern="/**" filters="none" />
		<form-login />
	</http>

	<!--
		Dummy class created purely because security namespace tag "http"
		requires an AuthenticationEntryPoint. Note that this class never gets
		used as we are not (we cannot!) relying on Spring Security to redirect
		the user to the login page. Remember that here we are dealing with GWT
		RPC requests and NOT normal web requests. The only sensible thing to
		do is to, in GWT server-side code, explicitly handle exceptions thrown
		by the AbstractSecurityInterceptor (Method Security interceptor in
		this case) to either "redirect" the user to the login page or display
		"access denied" messages.
	-->
	<bean id="dummyEntryPoint"
		class="com.kenstevens.stratinit.server.security.DummyEntryPoint" />

	<!--
		An AuthenticationProvider must be present in order to specify Spring
		Security declaratively using the security namespace, even though this
		provider will never be used as we are not relying on the filter chain
		mechanism for authentication - we have not defined any
		"authenticating" SpringSecurityFilter in the filter chain.
		Furthermore, Spring Method Security interceptor does not
		reauthenticate by default; it will happily accept any authenticated
		"Authentication" found in the security context, which our own
		authentication mechanism will have created.
	-->
	<!--
		<bean id="dummyAuthenticationProvider"
		class="com.kenstevens.stratinit.server.security.DummyAuthenticationProvider">
		<security:custom-authentication-provider /> </bean>
	-->
	<security:global-method-security
		secured-annotations="enabled" jsr250-annotations="disabled" />

	<security:authentication-provider>
		<security:password-encoder hash="sha" />
		<security:jdbc-user-service
			data-source-ref="dataSource"
			authorities-by-username-query="select p.username, r.rolename from player p, playerrole r where p.username=? and r.player_id = p.id"
			users-by-username-query="SELECT username,password,enabled FROM player WHERE username = ?" />
	</security:authentication-provider>
</beans>